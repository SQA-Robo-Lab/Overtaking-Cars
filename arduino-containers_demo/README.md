# Arduino Containers Demo

The purpose of this directory is to demonstrate the implementation of a cooperative overtaking scenario using the MechatronicUML Tool Suite and the code generation features of the extended platform-modeling approach.

The target platform are the robot cars described in https://github.com/SQA-Robo-Lab/Arduino-Car

For additional documentation, consult https://github.com/SQA-Robo-Lab/MUML-CodeGen-Wiki. 

The subdirectories contain the generated code and the required manual adaptions, as explained in the following.

## APImappings

The method stubs are created as part of the Arduino Container Code generator. Their implementation was not generated using the ApiML and ApiMappingML, but implemented manually using the robotCarLibs.

## components4Arduino

This directory contains all the code generated by the C Component Type Code Generation

However, the component type code requires some adaptions at the moment to be built for the Arduino environment:
* All files (except two, see next) were removed from their directories and collected in one main directory. Thus, all include paths were adjusted.
* The files **not copied** from the component type code are: ```lib/standardTypes.h``` (```types/standardTypes.h``` is used instead) and ```lib/clock.h``` (the ```clock.h``` file from the container code generation is used instead)
* In the ```...Component_Interface.h``` files: The ```clock.h``` file was pulled up to be outside of the ```extern "C" {...}``` part!
* In the ```robotCarPowerTrainOpRep.h```, which contains the operation repository method stub definitions, the ```lineFollower.h``` robot car lib is inlcuded, and in the ```robotCarPowerTrainOpRep.c``` it is used to implement the method stubs.

## mosquitto

The generated Docker configuration for starting up a mosquitto MQTT Sever, see ```README.txt```.

## robotCarLibs

The robot car libraries to implement the device functionality, see https://github.com/SQA-Robo-Lab/Arduino-Car as LineFollowerLibs.

## README.txt

The README file generated by the Arduino Container Code generator.

## The other directories

The other directories contain the code generated by the Arduino Container Code generator. The container code provides the environment for the component code to be executed. To enable the build using the Arduino tools, the following files were copied into each of the four ECU directories:
* The ```APImappings``` code.
* The ```components4Arduino``` code. When copied into the respective ECU directories, the values for the ```desiredVelocity``` and ```slowVelocity``` can be set individually in the ```driveControlDriveControlComponentStateChart.c``` of the ```...DriverECU``` directories.
* The ```robotCarLibs``` as they are included by the above code.
* In the main files of the Driver ECUs: The initialization functions of the robotCarLibs have to be added manually, i.e., 
    ```
    initializeDistanceSensors();
    initLineFollower();
    ```
    The reason is, that the initilization of devices is currently not supported by the the code generation.

Instead of copying all code, it is sufficient to copy the required files, i.e., the coordinator ECUs only needs the coordinatorComponent and no APImappings, and the fastCarDriver needs the ```...F...``` APImappings, the operation repostiories, and all the other components.

Furthermore, each directory contains configurations for VisualStudio Code with the Arduino and C/C++ extensions. Thus, the code for the four ECU directories can be built either with the Arduino IDE or VisualStudio Code.

## Build, Deployment, Testing

The generated code can be successfully built using the Arduino tools (```verify```).

Using the ```upload``` function of the Arduino environment, the code can be deployed on the robot car. The ```...DeriverECU``` to the respective Arduino Mega, and the ```...CoordinatorECU``` to the respective car's Arduino Nano. 

Following behavior was tested:
* The upload to the Arduino Mega makes the car follow a line on the ground, as the initial state of its component state chart suggests. However, it fails to transition into another state, even if there is an obstacle / a different car ahead.
* The upload to the Nano is successful and makes the ECU connect to the specified MQTT server. However, if the DEBUG flag is set in order to observe the behavior via a serial connection to the laptop, the Arduino tools warn that the memory is limited and the program might be unstable. Occasionally, this leads to a program crahs and makes the Arduino restart - the exact occurance of the program crash has not yet been examined. Commenting out the component behavior in the source code reliably prevents the program from crashing, and also the according warning in the Arduino environment is no longer shown. However, obviously, the component behavior is then not executed anymore.
* A brief test on whether the Coordinator component behavior may be executed with a larger ECU has flatlined due to initialization problems of the WiFi module when it is connected to an Arduino Mega. This was however only briefly tested and may certainly be fixible. This would be a good next step to take.
* The overtaking maneuver execution, i.e., changing langes with maintaining a reasonable distance to the car beeing passed, has not been tested yet. The reason is that the corresponding continuous behavior, i.e., the implementation in the robot car libararies, has not been implemented thus far. See https://github.com/SQA-Robo-Lab/Arduino-Car. 